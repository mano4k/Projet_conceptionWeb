"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getLocations = exports.findLocationsByState = exports.findLocationsByProvince = exports.findLocationsByCountryName = exports.findLocationsByCountryIso = exports.findLocationsByCoordinates = void 0;
const data_1 = require("./data");
const helpers_1 = require("./helpers");
/**
 * @func findLocationsByCoordinates Find locations based on coordinates.
 *
 * @param   {latitudeFrom}   number  Latitude from
 * @param   {latitudeTo}     number  Latitude to
 * @param   {longitudeFrom}  number  Longitude from
 * @param   {longitudeTo}    number  Longitude to
 * @return  {Location[]}
 */
const findLocationsByCoordinates = function findLocationsByCoordinates({ latitudeFrom, latitudeTo, longitudeFrom, longitudeTo, }) {
    const latFrom = (0, helpers_1.is)(Number, latitudeFrom) ? latitudeFrom : Number.NEGATIVE_INFINITY;
    const latTo = (0, helpers_1.is)(Number, latitudeTo) ? latitudeTo : Number.POSITIVE_INFINITY;
    const longFrom = (0, helpers_1.is)(Number, longitudeFrom) ? longitudeFrom : Number.NEGATIVE_INFINITY;
    const longTo = (0, helpers_1.is)(Number, longitudeTo) ? longitudeTo : Number.POSITIVE_INFINITY;
    // at least one of each value is necessary
    if ((!(0, helpers_1.exists)(latitudeFrom) && !(0, helpers_1.exists)(latitudeTo))
        || (!(0, helpers_1.exists)(longitudeFrom) && !(0, helpers_1.exists)(longitudeTo))) {
        return [];
    }
    const res = data_1.locations.filter((location) => (location.latitude >= latFrom
        && location.latitude <= latTo
        && location.longitude >= longFrom
        && location.longitude <= longTo));
    return res;
};
exports.findLocationsByCoordinates = findLocationsByCoordinates;
/**
 * @func findLocationsByCountryIso Find locations based on a country ISO 3166-1 alpha-2
 * or alpha-3 code.
 *
 * @param   {string}  code  Country ISO code (case insensitive)
 * @return  {Location[]}
 */
const findLocationsByCountryIso = function findLocationsByCountryIso(code) {
    if (!(0, helpers_1.is)(String, code)) {
        return [];
    }
    const countryCode = code.toUpperCase();
    const { valid, iso2 } = (0, helpers_1.isValidCountryIso)(countryCode);
    if (!valid) {
        return [];
    }
    const alphaType = iso2 ? 'iso2' : 'iso3';
    const res = data_1.locations.filter((location) => (0, helpers_1.match)({
        source: location.country[alphaType],
        compare: countryCode,
        partial: false,
        strict: true,
    }));
    return res;
};
exports.findLocationsByCountryIso = findLocationsByCountryIso;
/**
 * @func findLocationsByCountryName Find locations based on a country name.
 *
 * @param   {string}        name     Country name (case insensitive)
 * @param   {boolean}       partialMatch  Whether to include partial matches
 * @return  {Location[]}
 */
const findLocationsByCountryName = function findLocationsByCountryName(name, partialMatch = false) {
    if (!(0, helpers_1.is)(String, name)) {
        return [];
    }
    const partial = partialMatch === true;
    const res = data_1.locations.filter((location) => (0, helpers_1.match)({
        partial,
        source: location.country.name,
        compare: name,
        strict: false,
    }) || (0, helpers_1.match)({
        partial,
        source: location.country.officialName,
        compare: name,
        strict: false,
    }));
    return res;
};
exports.findLocationsByCountryName = findLocationsByCountryName;
/**
 * @func findLocationsByProvince Find locations based on a province
 * (not recommended, unreliable data).
 *
 * @param   {string}        name  Province name (case insensitive)
 * @param   {boolean}       partialMatch Whether to include partial matches
 * @return  {Location[]}
 */
const findLocationsByProvince = function findLocationsByProvince(name, partialMatch = false) {
    if (!(0, helpers_1.is)(String, name)) {
        return [];
    }
    const partial = partialMatch === true;
    const res = data_1.locations.filter((location) => (0, helpers_1.match)({
        partial,
        source: location.province,
        compare: name,
        strict: false,
    }));
    return res;
};
exports.findLocationsByProvince = findLocationsByProvince;
/**
 * @func findLocationsByState Find locations based on the state name.
 *
 * @param   {string}          name  State name (case insensitive, 2 chars)
 * @param   {boolean}         partialMatch  Whether to include partial matches
 * @return  {Location[]}
 */
const findLocationsByState = function findLocationsByState(name, partialMatch = false) {
    if (!(0, helpers_1.is)(String, name)) {
        return [];
    }
    const partial = partialMatch === true;
    const res = data_1.locations.filter((location) => (0, helpers_1.match)({
        partial,
        source: location.state,
        compare: name,
        strict: false,
    }));
    return res;
};
exports.findLocationsByState = findLocationsByState;
/**
 * @func getLocations Get all locations.
 *
 * @return  {Location[]}
 */
const getLocations = function getLocations() {
    return data_1.locations;
};
exports.getLocations = getLocations;
